# Copyright (C) 2014-2022, Xilinx, Inc.  All rights reserved.
# Copyright (C) 2022, Advanced Micro Devices, Inc.  All rights reserved.
#
# SPDX-License-Identifier: MIT

proc generate_system_dtsi {system_dtsi machine_dtsi} {
	global out_dir kconfig_dict target_cpu
	set fid [open $system_dtsi w+]
	puts $fid {/*
 * CAUTION: This file is automatically generated by PetaLinux SDK.
 * DO NOT modify this file
 */
}
	set cpu_arch [get_sw_proc_arch $target_cpu]

	puts $fid "\n/ \{"
	gen_dts_chosen $fid
	gen_dts_memory_node $fid
	gen_atf_reserved_node $fid
	gen_dts_u_boot_node $fid
	puts $fid "\};\n"
	gen_dts_ethernet_node $fid
	gen_dts_flash_node $fid ${machine_dtsi}
	close $fid
}

proc get_reset_gpio_id {} {
	global kconfig_dict
	set ch_no 0
	while {$ch_no < 10} {
		if {[dict exists $kconfig_dict reset_gpio "channel${ch_no}_select"]} {
			set value [dict get $kconfig_dict reset_gpio "channel${ch_no}_select"]
			if {[string equal $value "y"]} {
				return $ch_no
			}
		}
		incr ch_no
	}
	return null
}

proc gen_dts_reset_gpio {fid} {
	global kconfig_dict
	if {![dict exists $kconfig_dict reset_gpio inst_name]} {
		return
	}
	set reset_gpio_inst_name [dict get $kconfig_dict reset_gpio inst_name]
	set reset_gpio_ch_id [get_reset_gpio_id]
	puts $fid "\thard-reset-gpios = <&${reset_gpio_inst_name} ${reset_gpio_ch_id} 1>;"
}

proc gen_dts_aliases {fid} {
	global kconfig_dict
	set gen_aliases 0
	if {[dict exists $kconfig_dict serial inst_name]} {
		set uart_inst_name [dict get $kconfig_dict serial inst_name]
		set gen_aliases 1
	}
	if {[dict exists $kconfig_dict ethernet inst_name]} {
		set eth_inst_name [dict get $kconfig_dict ethernet inst_name]
		set gen_aliases 1
	}
	if {[dict exists $kconfig_dict flash inst_name]} {
		set flash_type [dict get $kconfig_dict flash flash_type]
		if { "${flash_type}" == "spi" } {
			set spiflash_inst_name [dict get $kconfig_dict flash inst_name]
			set gen_aliases 1
		} elseif { "${flash_type}" == "nand" } {
			set nandflash_inst_name [dict get ${kconfig_dict} flash inst_name]
			set get_aliases 1
		}
	}
	if {[dict exists $kconfig_dict rtc inst_name]} {
		set rtc_inst_name [dict get $kconfig_dict rtc inst_name]
		set gen_aliases 1
	}
	if {$gen_aliases == 1} {
		puts $fid "\taliases \{"
		if {[info exists uart_inst_name]} {
			set uart_inst_name [ps_node_mapping ${uart_inst_name} label]
			puts $fid "\t\tserial0 = &${uart_inst_name};"
		}
		if {[info exists eth_inst_name]} {
			set eth_inst_name [ps_node_mapping ${eth_inst_name} label]
			puts $fid "\t\tethernet0 = &${eth_inst_name};"
		}
		if {[info exists spiflash_inst_name]} {
			set spiflash_inst_name [ps_node_mapping ${spiflash_inst_name} label]
			puts $fid "\t\tspi0 = &${spiflash_inst_name};"
		}
		if {[info exists nandflash_inst_name]} {
			set nandflash_inst_name [ps_node_mapping ${nandflash_inst_name} label]
			puts $fid "\t\tnand0 = &${nandflash_inst_name};"
		}
		if {[info exists rtc_inst_name]} {
			set rtc_inst_name [ps_node_mapping ${rtc_inst_name} label]
			puts $fid "\t\trtc0 = &${rtc_inst_name};"
		}
		puts $fid "\t\};"
	}
}

proc gen_dts_chosen {fid} {
	global kconfig_dict target_cpu
	set cpu_arch [get_sw_proc_arch $target_cpu]
	if {[dict exists $kconfig_dict subsys_conf bootargs_generated]} {
		set bootargs [dict get $kconfig_dict subsys_conf bootargs_generated]
	} elseif {[dict exists $kconfig_dict subsys_conf user_cmdline]} {
		set bootargs [dict get $kconfig_dict subsys_conf user_cmdline]
	} else {
		set bootargs ""
	}

	puts $fid "\tchosen \{"
	puts $fid "\t\tbootargs = \"${bootargs}\";"
	set uart_baudrate "notfound"
	set serial_node "serial0"
	if {[dict exists $kconfig_dict serial inst_name]} {
		set uart_inst_name [dict get $kconfig_dict serial inst_name]
		if {[dict exists $kconfig_dict serial baudrate ${uart_inst_name}]} {
			set uart_baudrate [dict get $kconfig_dict serial baudrate ${uart_inst_name}]
		}
		if {[dict exists $kconfig_dict subsys_conf enable_no_alias]} {
			set ip_name [hsi get_property IP_NAME [hsi get_cells -hier $uart_inst_name]]
			append ip_name "_"
			set trimmed_ip [ string range $uart_inst_name [expr {[string first $ip_name $uart_inst_name]}] end]
			set serial_no [string trim $trimmed_ip $ip_name]
			if {[llength $serial_no]} {
				set serial_node "serial$serial_no"
			}
			puts "uart_inst_name:$uart_inst_name -> serial_no:$serial_no"
		}
	}
	puts $fid "\t\tstdout-path = \"${serial_node}:${uart_baudrate}n8\";"
	puts $fid "\t\};\n"
}

proc gen_dts_ethernet_node {fid} {
	global kconfig_dict
	if {![dict exists $kconfig_dict ethernet]} {
		return
	}
	set eth_inst_name [dict get $kconfig_dict ethernet inst_name]
	set mac [dict get $kconfig_dict ethernet mac]
	regsub -all {:} $mac { } mac
	set eth_inst_name [ps_node_mapping ${eth_inst_name} label]
	puts $fid "&${eth_inst_name} \{"
	puts $fid "\tlocal-mac-address = \[${mac}\];"
	puts $fid "\};\n"
}
proc gen_dts_memory_node {fid} {
	global kconfig_dict target_cpu
	if { [ string match -nocase "*cortexa9*" $target_cpu ] || [ string match -nocase "*cortexa53*" $target_cpu ] } {
		if { [dict exists $kconfig_dict subsys_conf memory_manual_select] } {
			set mem_reg ""
			set mem_lower_base [dict get $kconfig_dict subsys_conf memory_manual_lower_baseaddr]
			set mem_lower_size [dict get $kconfig_dict subsys_conf memory_manual_lower_memorysize]
			if { ![ string equal $mem_lower_size "0x0" ] } {
				if { [string match -nocase "*cortexa9*" $target_cpu ] } {
					append mem_reg "<${mem_lower_base} ${mem_lower_size}>"
				} else {
					set mem_lowerbase_msb [format "0x%08x" [expr $mem_lower_base >> 32]]
					set mem_lowerbase_lsb [format "0x%08x" [expr $mem_lower_base & 0x0ffffffff]]
					set mem_lowersize_msb [format "0x%08x" [expr $mem_lower_size >> 32]]
					set mem_lowersize_lsb [format "0x%08x" [expr $mem_lower_size & 0x0ffffffff]]
					append mem_reg "<${mem_lowerbase_msb} ${mem_lowerbase_lsb} ${mem_lowersize_msb} ${mem_lowersize_lsb}>"
				}
			}
			if { [ string match -nocase "*cortexa53*" $target_cpu ] } {
				set mem_upper_base [dict get $kconfig_dict subsys_conf memory_manual_upper_baseaddr]
				set mem_upper_size [dict get $kconfig_dict subsys_conf memory_manual_upper_memorysize]
				if { ![ string equal $mem_upper_size "0x0" ] } {
					set mem_upperbase_msb [format "0x%08x" [expr $mem_upper_base >> 32]]
					set mem_upperbase_lsb [format "0x%08x" [expr $mem_upper_base & 0x0ffffffff]]
					set mem_uppersize_msb [format "0x%08x" [expr $mem_upper_size >> 32]]
					set mem_uppersize_lsb [format "0x%08x" [expr $mem_upper_size & 0x0ffffffff]]
					if { ![ string equal $mem_reg  "" ] } {
						append mem_reg ","
					}
					append mem_reg "<${mem_upperbase_msb} ${mem_upperbase_lsb} ${mem_uppersize_msb} ${mem_uppersize_lsb}>"
				}
			}
			if { ![ string equal $mem_reg "" ] } {
				puts $fid "\tmemory \{"
				puts $fid "\t\tdevice_type = \"memory\";"
				puts $fid "\t\treg = ${mem_reg};"
				puts $fid "\};\n"
			}
		}
	}
}

proc gen_atf_reserved_node {fid} {
	global kconfig_dict target_cpu
	if { [ string match -nocase "*cortexa53*" $target_cpu ] || [ string match -nocase "*cortexa72*" $target_cpu ] } {
		puts $target_cpu
		if { [dict exists $kconfig_dict subsys_conf atf_memory_settings] } {
			set atf_mem_base [dict get $kconfig_dict subsys_conf atf_mem_base]
			set atf_mem_size [dict get $kconfig_dict subsys_conf atf_mem_size]
			if { [ string equal $atf_mem_base "" ] || [ string equal $atf_mem_size "" ] } {
				return
			}
			puts $fid "\treserved-memory \{"
			puts $fid "\t\t#address-cells = <2>;"
			puts $fid "\t\t#size-cells = <2>;"
			puts $fid "\t\tranges;"
			puts $fid "\t\t\tatf_region: atf@${atf_mem_base} \{"
			puts $fid "\t\t\treg = <0x0 ${atf_mem_base} 0x0 ${atf_mem_size}>;"
			puts $fid "\t\t\tno-map;"
			puts $fid "\t\t\t\};\n\t\};\n"
		}
	}
}

proc gen_spi_flash_node {fid machine_dtsi} {
	global target_cpu
	set spi_mode 0
	puts $fid "\t#address-cells = <1>;"
	puts $fid "\t#size-cells = <0>;"
	set is_quad [hsi get_cells -hier -filter { \
		IP_NAME == "axi_quad_spi" || IP_NAME == "psu_qspi" || \
		IP_NAME == "psv_pmc_qspi" || IP_NAME == "psv_pmc_qspi_ospi" || \
		IP_NAME == "psx_pmc_qspi" || IP_NAME == "psx_pmc_qspi_ospi" \
		}]
	foreach ip $is_quad {
		set ip_name [hsi get_property IP_NAME [hsi get_cells -hier $ip]]
		if { $ip_name eq "axi_quad_spi" } {
			set spi_mode [hsi get_property CONFIG.C_SPI_MODE [hsi get_cells -hier $ip]]
		} elseif { $ip_name eq "psu_qspi" } {
			set spi_mode [hsi get_property CONFIG.C_QSPI_MODE [hsi get_cells -hier $ip]]
		} elseif { $ip_name eq "psv_pmc_qspi" } {
			set spi_mode [hsi get_property CONFIG.C_QSPI_MODE [hsi get_cells -hier $ip]]
		} elseif { $ip_name eq "psv_pmc_qspi_ospi" } {
			set spi_mode [hsi get_property CONFIG.C_QSPI_MODE [hsi get_cells -hier $ip]]
		} elseif { $ip_name eq "psx_pmc_qspi" } {
			set spi_mode [hsi get_property CONFIG.C_QSPI_MODE [hsi get_cells -hier $ip]]
		} elseif { $ip_name eq "psx_pmc_qspi_ospi" } {
			set spi_mode [hsi get_property CONFIG.C_QSPI_MODE [hsi get_cells -hier $ip]]
		}
	}
	puts $fid "\tflash0: flash@0 \{"
	set cpu_arch [get_sw_proc_arch $target_cpu]
	if {$cpu_arch == "microblaze"} {
		puts $fid "\t\tcompatible = \"n25q512a\",\"jedec,spi-nor\";"
		puts $fid "\t\treg = <0x0>;"
		puts $fid "\t\t#address-cells = <1>;"
		puts $fid "\t\t#size-cells = <1>;"
	}
	if {$spi_mode == 2} {
		#Add quad mode flash support
		puts $fid "\t\tspi-tx-bus-width=<4>;"
		puts $fid "\t\tspi-rx-bus-width=<4>;"
	}

	set freq 50000000
	global kconfig_dict
	if {![dict exists $kconfig_dict flash]} {
		return
	}
	set cpu_arch [get_sw_proc_arch $target_cpu]
	if {$cpu_arch == "microblaze"} {
		set flash_inst_name [dict get $kconfig_dict flash inst_name]
		set flash_bank [dict get $kconfig_dict flash bank]
		set ip_obj [hsi get_cells -hier $flash_inst_name]
		set prop_rt_code [catch {hsi get_property CONFIG.C_SCK_RATIO $ip_obj}]

		set def_clk_pin "S_AXI_ACLK"
		# FIXME: correct detection for XIP mode is required as XIP mode has both
		# S_AXI_ACLK and S_AXI4_ACLK clock pins
		if {[hsi get_property CONFIG.C_XIP_MODE $ip_obj] == 1} {
			set def_clk_pin "S_AXI_ACLK"
		} elseif {[hsi get_property CONFIG.C_TYPE_OF_AXI4_INTERFACE $ip_obj] == 1} {
			set def_clk_pin "S_AXI4_ACLK"
		}
		set rt_code [catch {hsi get_pins -of_objects $ip_obj $def_clk_pin}]
		if {$rt_code == 0 && $prop_rt_code == 0} {
			# set freq = bus_freq / spi_sck_ratio
			set clk [hsi get_pins -of_objects $ip_obj $def_clk_pin]
			if {[llength $clk]} {
				set spi_sck_ratio [hsi get_property CONFIG.C_SCK_RATIO $ip_obj]
				set bus_freq [hsi get_property CLK_FREQ $clk]
				# make sure expr works
				if {![catch {expr {$bus_freq / $spi_sck_ratio}}]} {
					set freq [expr {$bus_freq / $spi_sck_ratio}]
				}
			}
		}
		puts $fid "\t\tspi-max-frequency = <${freq}>;"
	}
	set machine_name ""
	if {[dict exists $kconfig_dict subsys_conf machine_name]} {
		set machine_name [dict get $kconfig_dict subsys_conf machine_name ]
	}
	if { ![ string equal $machine_name "template" ] } {
		set remove_nodes "partition@0 partition@100000 partition@600000 partition@620000 partition@c00000"
		foreach node $remove_nodes {
			puts $fid "\t\t/delete-node/ $node;"
		}
	}
	gen_part_table $fid {	}
	puts $fid "\t\};"
}

proc gen_nor_flash_node {fid machine_dtsi} {
	global kconfig_dict
	set flash_inst_name [dict get $kconfig_dict flash inst_name]
	set flash_type [dict get $kconfig_dict flash flash_type]
	set flash_bank [dict get $kconfig_dict flash bank]
	set flash_base [get_ip_property $flash_inst_name $flash_bank BASEADDR]
	set flash_high [get_ip_property $flash_inst_name $flash_bank HIGHADDR]
	set flash_size [format "0x%08x" [expr $flash_high -$flash_base + 1]]
	puts $fid "\treg = <${flash_base} ${flash_size}>;"
	puts $fid "\t#address-cells = <1>;"
	puts $fid "\t#size-cells = <1>;"
	gen_part_table $fid {}
}

proc gen_nand_flash_node {fid machine_dtsi} {
	puts $fid "\tnand@0 \{"
	gen_part_table $fid "\t"
	puts $fid "\t\};"
}

proc gen_part_table {fid tab} {
	global kconfig_dict
	set part_no 0
	set flash_type [dict get $kconfig_dict flash flash_type]
	while {$part_no < 20} {
		if {[dict exists $kconfig_dict flash "part$part_no" "name"]} {
			set part_name [dict get $kconfig_dict flash "part$part_no" "name"]
			set part_size [format "0x%08x" [dict get $kconfig_dict flash "part$part_no" "size"]]
			set part_offset [format "0x%08x" [dict get $kconfig_dict flash "part$part_no" "offset"]]
			if {[dict exists $kconfig_dict flash "part$part_no" "cntl_base"]} {
				set cntl_base [dict get $kconfig_dict flash "part$part_no" "cntl_base"]
				set part_offset  [format "0x%08x" [expr $part_offset - $cntl_base]]
			}
			if { "${flash_type}" == "nand" } {
				set part_offset [format "%s %s" "0x0" "${part_offset}"]
			}
			puts $fid "${tab}\tpartition@${part_no} \{"
			puts $fid "${tab}\t\tlabel = \"${part_name}\";"
			puts $fid "${tab}\t\treg = <${part_offset} ${part_size}>;"

			puts $fid "${tab}\t\};"
		} else {
			break
		}
		incr part_no
	}
}

proc gen_dts_flash_node {fid machine_dtsi} {
	global kconfig_dict
	if {![dict exists $kconfig_dict flash]} {
		return
	}
	set flash_inst_name [dict get $kconfig_dict flash inst_name]
	set flash_inst_name [ps_node_mapping ${flash_inst_name} label]
	set flash_type [dict get $kconfig_dict flash flash_type]
	puts $fid "&${flash_inst_name} \{"
	eval "gen_${flash_type}_flash_node \$fid \$machine_dtsi"
	puts $fid "\};\n"
}

proc remove_dts_node args {
	# TODO: remove dts-v1 and model should not be part of this script
	# remove dts node and /dts-v1/; from the dts file
	set dts [lindex $args 0]
	set node [lrange $args 1 end]

	set fid [open $dts r]
	set file_data [read $fid]
	set data [split $file_data "\n"]
	close $fid
	set node_found 0
	foreach line $data {
		if {[regexp "/dts-v1/;" $line matched] || \
			[regexp "model =" $line matched]} {
			continue
		}
		if {[regexp "${node}.*\{*" $line matched]} {
			set node_found 1
			break
		}
			}
	return $node_found
}

proc remove_dts_property args {
	# TODO: remove dts-v1 and model should not be part of this script
	# remove dts node and /dts-v1/; from the dts file
	set dts [lindex $args 0]
	set node [lindex $args 1]
	set property_list [lrange $args 2 end]

	set fid [open $dts r]
	set file_data [read $fid]
	set data [split $file_data "\n"]
	close $fid

	set new_data ""
	set node_found 0
	foreach line $data {
		set prop_found 0
		if {[regexp "${node}.*\{" $line matched]} {
			set node_found 1
			set count 0
		}
		if {$node_found == 1} {
			foreach prop $property_list {
				if {[regexp ".*$prop.*=.*" $line matched]} {
					set prop_found 1
				}
			}
		}
		if {$prop_found == 1} {
			continue
		}
		if {[regexp ".*\{" $line matched]} {
			incr count 1
		}
		if {[regexp ".*\}.*;" $line matched]} {
			if {$count == 0} {
				set node_found 0
			} else {
				incr count -1
			}
		}
		lappend new_data $line
	}
	set fid [open $dts w+]
	puts $fid [join $new_data "\n"]
	close $fid
}

proc get_ip_property {ip bank prop} {
	set ip_obj [hsi get_cells -hier $ip]
	set rt [hsi report_property -return_string -regexp $ip_obj  CONFIG.*${bank}_$prop.*]
	foreach line [split $rt "\n"] {
		regsub -all {\s+} $line { } line
		if {[regexp "CONFIG.*${bank}_$prop.*" $line matched]} {
			set property_name [lindex [split $line " "] 0]
			return [hsi get_property "${property_name}" ${ip_obj}]
		}
	}
	#puts [hsi get_property -regexp CONFIG.*$prop.* $ip_obj]
	error "unable to find the property"
}

proc create_soc_mapping_from_dts_file {zynq_soc_dtsi} {
	set fp [open $zynq_soc_dtsi r]
	set file_data [read $fp]
	regsub -all ",\n" $file_data {,} file_data
	set data [split $file_data "\n"]
	set node_level -1
	foreach line $data {
		set node_start_regexp "\{(\\s+|\\s|)$"
		set node_end_regexp "\}(\\s+|\\s|);(\\s+|\\s|)$"
		set reg_node_regexp "reg = "
		if {[regexp $node_start_regexp $line matched]} {
			regsub -all "\{| |\t" $line {} line
			incr node_level
			set cur_node [line_to_node $line $node_level]
		} elseif {[regexp $node_end_regexp $line matched]} {
			set node_level [expr "$node_level - 1"]
		} elseif {[regexp $reg_node_regexp $line matched]} {
                        set cur_node [line_to_node $line $node_level]
		}
	}
}

proc line_to_node {line node_level} {
	global ps7_mapping
	# TODO: make dt_node_dict as global
	global dt_node_dict
	global def_string
	global node_label
	set reg_node_regexp "reg = "
	set node_data [split $line ":"]
	set node_data_size [llength $node_data]
	set reg [split $line "="]
	set reg_data [lindex $reg 1]
	set reg_data_size [llength $reg_data]
	if {$node_data_size == 2} {
		set node_label [lindex $node_data 0]
		set tmp_data [split [lindex $node_data 1] "@"]
		set node_name [lindex $tmp_data 0]
		if {[llength $tmp_data] >= 2} {
			set node_unit_addr [lindex $tmp_data 1]
			dict set ps7_mapping $node_unit_addr label $node_label
		}

        } elseif {$reg_data_size == 8} {
		set node_unit_addr [lindex $reg_data 5]
		regsub -all {^0x} $node_unit_addr {} node_unit_addr
		dict set ps7_mapping $node_unit_addr label $node_label
	} elseif {$node_data_size == 1} {
		set node_name [lindex $node_data 0]
	} else {
		error "invalid node found - $line"
	}

}

proc ps_node_mapping {ip_name prop} {
	set unit_addr [get_ps_node_unit_addr $ip_name]
	if {$unit_addr == -1} {return $ip_name}
	global ps7_mapping
	if {[is_ps_ip [hsi get_drivers $ip_name]]} {
		if {[catch {set tmp [dict get $ps7_mapping $unit_addr $prop]} msg]} {
			continue
		}
		return $tmp
	}
	return $ip_name
}

proc get_ps_node_unit_addr {ip_name {prop "label"}} {
	set ip [hsi get_cells -hier $ip_name]
	set ip_mem_handle [hsi::utils::get_ip_mem_ranges [hsi get_cells -hier $ip]]

	# loop through the base addresses: workaround for intc
	foreach handler ${ip_mem_handle} {
		set unit_addr [string tolower [hsi get_property BASE_VALUE $handler]]
		regsub -all {^0x} $unit_addr {} unit_addr
		global ps7_mapping
		if {[is_ps_ip [hsi get_drivers $ip_name]]} {
			if {[catch {set tmp [dict get $ps7_mapping $unit_addr $prop]} msg]} {
				continue
			}
			return $unit_addr
		}
	}
	return -1
}

proc is_ps_ip {ip_inst} {
	# check if the IP is a soft IP (not PS7)
	# return 1 if it is soft ip
	# return 0 if not
	set ip_obj [hsi get_cells -hier $ip_inst]
	if {[llength [hsi get_cells -hier $ip_inst]] < 1} {
		return 0
	}
	set ip_name [hsi get_property IP_NAME $ip_obj]
	if {[regexp "ps[7uvx]_*" "$ip_name" match]} {
		return 1
	}
	return 0
}

proc add_bootscr_flash_offset_size_prop {fid qspi_bootscr_offset qspi_bootscr_size} {
	puts $fid "\t\t\tbootscr-flash-offset = /bits/ 64 <${qspi_bootscr_offset}>;"
	puts $fid "\t\t\tbootscr-flash-size = /bits/ 64 <${qspi_bootscr_size}>;"
}

proc gen_dts_u_boot_node {fid} {
	global kconfig_dict
	set processor_ip_name [dict get $kconfig_dict processor ip_str]
	set processor_ip_name [hsi get_property IP_NAME [hsi get_cells -hier $processor_ip_name]]
	if {[string match {*microblaze*} $processor_ip_name]} {
		return
	}

	if {[dict exists $kconfig_dict subsys_conf memory_manual_lower_baseaddr]} {
		set memory_base_addr [dict get $kconfig_dict subsys_conf memory_manual_lower_baseaddr]
	} else {
		set memory_base_addr [dict get $kconfig_dict memory baseaddr]
	}
	set bootscr_offset [dict get $kconfig_dict subsys_conf uboot_bootscr_offset]
	set qspi_bootscr_offset [dict get $kconfig_dict subsys_conf uboot_qspi_bootscr_offset]
	set qspi_bootscr_size [dict get $kconfig_dict subsys_conf uboot_qspi_bootscr_size]
	if {![catch {dict get $kconfig_dict subsys_conf uboot_append_baseaddr}]} {
		set boot_script_loadaddr [format "0x%08x" [expr $memory_base_addr + $bootscr_offset]]
	} else {
		set boot_script_loadaddr $bootscr_offset
	}

	puts $fid "\toptions \{"
	puts $fid "\t\tu-boot \{"
	puts $fid "\t\t\tcompatible = \"u-boot,config\";"
	puts $fid "\t\t\tbootscr-address = /bits/ 64 <${boot_script_loadaddr}>;"
	if {![string match {*AUTO*} $qspi_bootscr_offset] && ![string match {*AUTO*} $qspi_bootscr_size]} {
		add_bootscr_flash_offset_size_prop $fid $qspi_bootscr_offset $qspi_bootscr_size
	}
	puts $fid "\t\t\};"
	puts $fid "\t\};"
}
